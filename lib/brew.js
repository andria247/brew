// Generated by IcedCoffeeScript 1.4.0a
(function() {
  var brew, crypto, file, fs, iced, path, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  path = require('path');

  crypto = require('crypto');

  brew = (function() {

    function brew(o) {
      var p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          o (dict argument): 
            includes: a sorted list of files and/or dirs to include
            excludes: (optional) any exceptions (files and/or dirs) to the includes
            match:    (optional) a regular expression any file must match; say if you want to limit to extensions
            compile:  (optional) fn to call on each file's contents; takes (filename, str, cb) as arguments; if missing, just returns text
            join:     (optional) fn takes all the (sorted) compiled strings and joins them together for final output
            onChange: (optional) a callback when anything changes in the brew. takes (passes version_hash, txt) as argument
            onReady:  (optional) a callback for when the first compilation pass is done and the brew is ready
            logger:   (optional) a function that handles lines of logs
      */

      this._includes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.includes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._excludes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.excludes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._match = o.match || /.*/;
      this._compile = o.compile || function(p, str, cb) {
        return cb(null, str);
      };
      this._join = o.join || function(strs, cb) {
        return cb(null, strs.join("\n"));
      };
      this._onChange = o.onChange || function(version_hash, txt) {};
      this._onReady = o.onReady || function(version_hash, txt) {};
      this._logger = o.logger || null;
      this._isCompiling = false;
      this._versionHash = null;
      this._txt = null;
      this._includeMembers = {};
      this._files = {};
      this._fs_watchers = {};
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew"
        });
        _this._fullPass(__iced_deferrals.defer({
          lineno: 32
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (o.onReady != null) {
          return o.onReady(_this.getVersionHash(), _this.getCompiledText());
        }
      });
    }

    brew.prototype.getVersionHash = function() {
      if (!((this._versionHash != null) && (this._txt != null))) {
        throw new Error("getVersionHash() called before onReady(); wait for your brew to brew!");
      }
      return this._versionHash;
    };

    brew.prototype.getCompiledText = function() {
      if (!((this._versionHash != null) && (this._txt != null))) {
        throw new Error("getCompiledText() called before onReady(); wait for your brew to brew!");
      }
      return this._txt;
    };

    brew.prototype._log = function(str) {
      if (this._logger != null) return this._logger(str);
    };

    brew.prototype._fullPass = function(cb) {
      var d, i, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      d = Date.now();
      this._isCompiling = true;
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this._includes;
        _len = _ref.length;
        i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _len)) {
            return _break();
          } else {
            p = _ref[i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._fullPass"
              });
              _this._recurse(p, i, __iced_deferrals.defer({
                lineno: 56
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew._fullPass"
          });
          _this._flipToNewContent(true, __iced_deferrals.defer({
            lineno: 57
          }));
          __iced_deferrals._fulfill();
        })(function() {
          _this._isCompiling = false;
          _this._log("[" + (Date.now() - d) + "ms] performed full pass");
          return cb();
        });
      });
    };

    brew.prototype._partialPass = function(path, priority) {
      var d, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          happens when we get an fs.watch trigger on a dir or file
      */

      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!_this._isCompiling) {
            return _break();
          } else {
            _this._log("deferring on compile of " + path + " while waiting for another compile");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._partialPass"
              });
              setTimeout(__iced_deferrals.defer({
                lineno: 68
              }), 50);
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        _this._isCompiling = true;
        d = Date.now();
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew._partialPass"
          });
          _this._recurse(path, priority, __iced_deferrals.defer({
            lineno: 71
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._partialPass"
            });
            _this._flipToNewContent(false, __iced_deferrals.defer({
              lineno: 72
            }));
            __iced_deferrals._fulfill();
          })(function() {
            _this._isCompiling = false;
            return _this._log("[" + (Date.now() - d) + "ms] performed partial pass of " + path + ";pri=" + priority);
          });
        });
      });
    };

    brew.prototype._flipToNewContent = function(is_first_pass, cb) {
      var d, err, f, fp, paths, res, txts, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          puts together all the compilations
          and generates a new version number
      */

      d = Date.now();
      paths = (function() {
        var _ref, _results;
        _ref = this._files;
        _results = [];
        for (fp in _ref) {
          f = _ref[fp];
          if (f.isOk()) _results.push(fp);
        }
        return _results;
      }).call(this);
      paths.sort(function(a, b) {
        return _this._files[a].getPriority() - _this._files[b].getPriority();
      });
      txts = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        fp = paths[_i];
        txts.push(this._files[fp].getCompiledText());
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._flipToNewContent"
        });
        _this._join(txts, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return res = arguments[1];
            };
          })(),
          lineno: 88
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (res !== _this._txt) {
          _this._txt = res;
          _this._versionHash = crypto.createHash('md5').update(_this._txt).digest('hex').slice(0, 8);
          if (!is_first_pass) _this._onChange(_this._versionHash, _this._txt);
          _this._log("[" + (Date.now() - d) + "ms] flipped to new content");
        } else {
          _this._log("[" + (Date.now() - d) + "ms] content unchanged");
        }
        return cb();
      });
    };

    brew.prototype._recurse = function(p, priority, cb) {
      var err, f, files, fp, stat, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          p:  a file or directory
      */

      (function(__iced_k) {
        if (__indexOf.call(_this._excludes, p) >= 0) {
          return __iced_k(_this._log("skipping " + p + " on recurse due to excludes"));
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._recurse"
            });
            fs.stat(p, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return stat = arguments[1];
                };
              })(),
              lineno: 106
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (!err) {
                (function(__iced_k) {
                  if (stat.isDirectory()) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/brew.coffee",
                        funcname: "brew._recurse"
                      });
                      fs.readdir(p, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return files = arguments[1];
                          };
                        })(),
                        lineno: 109
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        if (!err) {
                          (function(__iced_k) {
                            var _i, _len, _ref, _results, _while;
                            _ref = files;
                            _len = _ref.length;
                            _i = 0;
                            _results = [];
                            _while = function(__iced_k) {
                              var _break, _continue, _next;
                              _break = function() {
                                return __iced_k(_results);
                              };
                              _continue = function() {
                                return iced.trampoline(function() {
                                  ++_i;
                                  return _while(__iced_k);
                                });
                              };
                              _next = function(__iced_next_arg) {
                                _results.push(__iced_next_arg);
                                return _continue();
                              };
                              if (!(_i < _len)) {
                                return _break();
                              } else {
                                f = _ref[_i];
                                fp = path.join(p, f);
                                (function(__iced_k) {
                                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                                    parent: ___iced_passed_deferral,
                                    filename: "src/brew.coffee",
                                    funcname: "brew._recurse"
                                  });
                                  _this._recurse(fp, priority, __iced_deferrals.defer({
                                    lineno: 112
                                  }));
                                  __iced_deferrals._fulfill();
                                })(_next);
                              }
                            };
                            _while(__iced_k);
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    });
                  } else {
                    (function(__iced_k) {
                      if (stat.isFile()) {
                        (function(__iced_k) {
                          if (path.basename(p).match(_this._match)) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "src/brew.coffee",
                                funcname: "brew._recurse"
                              });
                              _this._recurseHandleFile(p, priority, __iced_deferrals.defer({
                                lineno: 115
                              }));
                              __iced_deferrals._fulfill();
                            })(__iced_k);
                          } else {
                            return __iced_k(_this._log("skipping " + p + " on recurse due to filename regexp match"));
                          }
                        })(__iced_k);
                      } else {
                        return __iced_k();
                      }
                    })(__iced_k);
                  }
                })(__iced_k);
              } else {
                if (_this._files[p] != null) delete _this._files[p];
                return __iced_k(_this._log("removing " + p + " from files; it went missing"));
              }
            })(function() {
              return __iced_k(_this._monitorForChanges(p, priority));
            });
          });
        }
      })(function() {
        return cb();
      });
    };

    brew.prototype._monitorForChanges = function(p, priority) {
      var _this = this;
      if (this._fs_watchers[p]) return;
      try {
        this._log("fs.watch() called for " + p);
        return this._fs_watchers[p] = fs.watch(p, {
          persistent: true
        }, function(evt, fn) {
          _this._log("fs.watch() triggered for " + p);
          _this._fs_watchers[p].close();
          delete _this._fs_watchers[p];
          return _this._partialPass(p, priority);
        });
      } catch (e) {
        return this._log("fs.watch() failed for " + p + "; it probably disappeared");
      }
    };

    brew.prototype._recurseHandleFile = function(p, priority, cb) {
      var d, did_reload, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      d = Date.now();
      if (this._files[p] == null) this._files[p] = new file(p, priority);
      this._files[p].setPriority(Math.min(priority, this._files[p].getPriority()));
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._recurseHandleFile"
        });
        _this._files[p].possiblyReload(_this._compile, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return did_reload = arguments[1];
            };
          })(),
          lineno: 143
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (did_reload) {
          _this._log("[" + (Date.now() - d) + "ms] read & compiled " + p);
        } else {
          _this._log("[" + (Date.now() - d) + "ms] ignored " + p + "; unchanged");
        }
        return cb();
      });
    };

    return brew;

  })();

  file = (function() {

    function file(p, priority) {
      /*
          p = path
          pri = 0, 1, etc. (0 is lowest)
      */
      this._path = p;
      this._priority = priority;
      this._src_txt = null;
      this._compiled_txt = null;
      this._err = null;
    }

    file.prototype.possiblyReload = function(compile_fn, cb) {
      var data, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "file.possiblyReload"
        });
        fs.readFile(_this._path, "utf8", __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return data = arguments[1];
            };
          })(),
          lineno: 165
        }));
        __iced_deferrals._fulfill();
      })(function() {
        _this._err = null;
        if (err) {
          _this._err = err;
          return __iced_k(cb(err, null));
        } else {
          (function(__iced_k) {
            if (data !== _this._src_txt) {
              _this._src_txt = data;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/brew.coffee",
                  funcname: "file.possiblyReload"
                });
                compile_fn(_this._path, _this._src_txt, __iced_deferrals.defer({
                  assign_fn: (function(__slot_1) {
                    return function() {
                      err = arguments[0];
                      return __slot_1._compiled_txt = arguments[1];
                    };
                  })(_this),
                  lineno: 173
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(cb(null, true));
              });
            } else {
              return __iced_k(cb(null, false));
            }
          })(__iced_k);
        }
      });
    };

    file.prototype.isOk = function() {
      return !this._err;
    };

    file.prototype.getCompiledText = function() {
      return this._compiled_txt;
    };

    file.prototype.getSrc = function() {
      return this._src;
    };

    file.prototype.getPriority = function() {
      return this._priority;
    };

    file.prototype.setPriority = function(pri) {
      return this._priority = pri;
    };

    return file;

  })();

  exports.brew = brew;

}).call(this);
