// Generated by CoffeeScript 1.4.0
(function() {
  var brew, file, fs, path;

  fs = require('fs');

  path = require('path');

  brew = (function() {

    function brew(o) {
      /*
          a (argument): 
            includes: a sorted list of files and/or dirs to include
            excludes: (optional) any exceptions (files and/or dirs) to the includes
            match:    (optional) a regular expression any file must match; say if you want to limit to extensions
            compile:  (optional) fn to call on each file; takes (filename, str, cb) as arguments; if missing, just returns text
            onChange: (optional) a callback when anything changes in the brew. takes (passes version_hash, txt) as argument
            onReady:  (optional) a callback for when the first compilation pass is done and the brew is ready
      */
      this._includes = a.includes || [];
      this._excludes = a.excludes || [];
      this._match = a.match || /.*/;
      this._compile = a.compile || function(p, str, cb) {
        return cb(null, str);
      };
      this._onChange = a.onChange || function() {};
      this._onReady = a.onReady || function() {};
      this._isCompiling = false;
      this._versionHash = null;
      this._txt = null;
      this._files = {};
      if (a.onReady != null) {
        a.onReady(this.getVersionHash(), this.getCompiledText());
      }
    }

    brew.prototype._fullPass = function(cb) {
      var p, _i, _len, _ref;
      this._isCompiling = true;
      _ref = this._includes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        await(_recurse(p, defer()));
      }
      this._isCompiling = false;
      return cb();
    };

    brew.prototype._recurse = function(p, cb) {
      /*
          p:  a file or directory
          cb: when done
      */

      var f, fp, _i, _len;
      await(fs.stat(p, defer(err, stat)));
      if (!err) {
        if (stat.isDirectory()) {
          await(fs.readdir(defer(err, files)));
          if (!err) {
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              f = files[_i];
              fp = path.join(p, f);
              await(_recurse(fp, defer()));
            }
          }
        } else if (stat.isFile()) {
          await(_recurseHandleFile(p, defer()));
        }
      }
      return cb();
    };

    brew.prototype._recurseHandleFile = function(p, cb) {
      this._files[p] = new file(p);
      await(this._files[p].possiblyReload(defer(err, did_reload)));
      return cb();
    };

    return brew;

  })();

  file = (function() {

    function file(p) {
      this._path = p;
      this._src_txt = null;
      this._compiled_txt = null;
    }

    file.prototype.possiblyReload = function(compile_fn, cb) {
      await(fs.readFile(this._path, defer(err, data)));
      if (err) {
        return cb(err, null);
      } else if (data !== this._src_txt) {
        this._src_txt = data;
        await(compile_fn(this._path, this._src_txt, defer(err, this._compiled_txt)));
        return cb(null, true);
      } else {
        return cb(null, false);
      }
    };

    return file;

  })();

  exports.brew = brew;

}).call(this);
